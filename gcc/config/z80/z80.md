;; Machine description for Moxie
;; Copyright (C) 2009-2014 Free Software Foundation, Inc.
;; Contributed by Anthony Green <green@moxielogic.com>
;
;; This file is part of GCC.
;
;; GCC is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published
;; by the Free Software Foundation; either version 3, or (at your
;; option) any later version.
;
;; GCC is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.
;
;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.
;
;; -------------------------------------------------------------------------
;; Moxie specific constraints, predicates and attributes
;; -------------------------------------------------------------------------
;
(include "constraints.md")
(include "predicates.md")
;
;; Most instructions are two bytes long.
(define_attr "length" "" (const_int 1))
;
;; -------------------------------------------------------------------------
;; nop instruction
;; -------------------------------------------------------------------------
;
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")
;
;; -------------------------------------------------------------------------
;; Arithmetic instructions
;; -------------------------------------------------------------------------
;
;(define_insn "addsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
;	  (plus:SI
;	   (match_operand:SI 1 "register_operand" "0,0,0")
;	   (match_operand:SI 2 "z80_add_operand" "I,N,r")))]
;  ""
;  "@
;  inc    %0, %2
;  dec	 %0, -%2
;  add.l  %0, %2")
;
;(define_insn "subsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r,r")
;	  (minus:SI
;	   (match_operand:SI 1 "register_operand" "0,0")
;	   (match_operand:SI 2 "z80_sub_operand" "I,r")))]
;  ""
;  "@
;  dec    %0, %2
;  sub.l  %0, %2")
;
;(define_insn "mulsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	  (mult:SI
;	   (match_operand:SI 1 "register_operand" "0")
;	   (match_operand:SI 2 "register_operand" "r")))]
;  ""
;  "mul.l  %0, %2")
;
;(define_insn "divsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	  (div:SI
;	   (match_operand:SI 1 "register_operand" "0")
;	   (match_operand:SI 2 "register_operand" "r")))]
;  ""
;  "div.l  %0, %2")
;
;(define_insn "udivsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	  (udiv:SI
;	   (match_operand:SI 1 "register_operand" "0")
;	   (match_operand:SI 2 "register_operand" "r")))]
;  ""
;  "udiv.l %0, %2")
;
;(define_insn "modsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	  (mod:SI
;	   (match_operand:SI 1 "register_operand" "0")
;	   (match_operand:SI 2 "register_operand" "r")))]
;  ""
;  "mod.l  %0, %2")
;
;(define_insn "umodsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	  (umod:SI
;	   (match_operand:SI 1 "register_operand" "0")
;	   (match_operand:SI 2 "register_operand" "r")))]
;  ""
;  "umod.l %0, %2")
;
;; -------------------------------------------------------------------------
;; Unary arithmetic instructions
;; -------------------------------------------------------------------------
;
;(define_insn "negsi2"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	  (neg:SI (match_operand:SI 1 "register_operand" "r")))]
;  ""
;  "neg    %0, %1")
;
;(define_insn "one_cmplsi2"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(not:SI (match_operand:SI 1 "register_operand" "r")))]
;  ""
;  "not    %0, %1")
;
;; -------------------------------------------------------------------------
;; Logical operators
;; -------------------------------------------------------------------------
;
;(define_insn "andsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(and:SI (match_operand:SI 1 "register_operand" "0")
;		(match_operand:SI 2 "register_operand" "r")))]
;  ""
;{
;  return "and    %0, %2";
;})
;
;(define_insn "xorsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(xor:SI (match_operand:SI 1 "register_operand" "0")
;		(match_operand:SI 2 "register_operand" "r")))]
;  ""
;{
;  return "xor    %0, %2";
;})
;
;(define_insn "iorsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(ior:SI (match_operand:SI 1 "register_operand" "0")
;		(match_operand:SI 2 "register_operand" "r")))]
;  ""
;{
;  return "or     %0, %2";
;})
;
;; -------------------------------------------------------------------------
;; Shifters
;; -------------------------------------------------------------------------
;
;(define_insn "ashlsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(ashift:SI (match_operand:SI 1 "register_operand" "0")
;		   (match_operand:SI 2 "register_operand" "r")))]
;  ""
;{
;  return "ashl   %0, %2";
;})
;
(define_expand "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (ashift:QI (match_operand:QI 1 "register_operand" "0")
                   (match_operand:QI 2 "immediate_operand" "i")))]
  ""
  "{
    for(int i = 0; i < INTVAL(operands[2]); i++) {
      emit_insn(gen_ashlqi2(operands[0], operands[0], GEN_INT(1)));
      DONE;
    }
  }")
(define_insn "ashlqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
        (ashift:QI (match_operand:QI 1 "register_operand" "0")
                   (match_operand:QI 2 "immediate_operand" "i")))]
  ""
  "sla %0 %2")
;; (define_insn "rotlqi3"
;;   [(set (match_operand:QI 0 "register_operand" "=r,m")
;;         (rotate:QI (match_operand:QI 1 "register_operand" "0,0")
;;                    (const_int:QI 1)))]
;;   ""
;;   "@
;;   rl %0
;;   rl %0")
;; (define_expand "ashlhi3"
;;   [(set (match_operand:HI 0 "register_operand")
;;         (ashift:HI (match_operand:HI 1 "register_operand" "0")
;;                    (match_operand:HI 2 "immediate_operand" "i")))]
;; ;;                   (const_int 1)))]
;;   "reload_completed"
;;   "printf(\"ashlhi3\\n\");")
;; (define_expand "ashlhi3"
;;   [(set (match_operand:HI 0 "register_operand" "=r")
;;         (ashift:HI (match_operand:HI 1 "register_operand" "0")
;;                    (match_operand:HI 2 "immediate_operand" "i")))]
;;   ""
;;   "DERP %0 %2")
;; (define_split ; "ashlhi3"
;;   [(set (match_operand:HI 0 "register_operand")
;;         (ashift:HI (match_operand:HI 1 "register_operand")
;;                    (const_int 1)))]
;;   ""
;;   [(set (subreg:QI (match_dup 0) 0)
;;         (ashift:QI (subreg:QI (match_dup 0) 0)
;;                    (const_int 1)))
;;    (set (subreg:QI (match_dup 0) 1)
;;         (rotate:QI (subreg:QI (match_dup 0) 1)
;;                    (const_int 1)))]
;;   "")
;(define_insn "ashrsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0")
;		     (match_operand:SI 2 "register_operand" "r")))]
;  ""
;{
;  return "ashr   %0, %2";
;})
;
;(define_insn "lshrsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
;		     (match_operand:SI 2 "register_operand" "r")))]
;  ""
;{
;  return "lshr   %0, %2";
;})
;
;; -------------------------------------------------------------------------
;; Move instructions
;; -------------------------------------------------------------------------
;
;; SImode
;
;; Push a register onto the stack
;(define_insn "movsi_push"
;  [(set (mem:SI (pre_dec:SI (reg:SI 1)))
;  	(match_operand:SI 0 "register_operand" "r"))]
;  ""
;  "push   $sp, %0")
;
;; Pop a register from the stack
;(define_insn "movsi_pop"
;  [(set (match_operand:SI 1 "register_operand" "=r")
;  	(mem:SI (post_inc:SI (match_operand:SI 0 "register_operand" "r"))))]
;  ""
;  "pop    %0, %1")
;
;(define_expand "movhi"
;   [(set (match_operand:HI 0 "general_operand" "")
; 	(match_operand:HI 1 "general_operand" ""))]
;   ""
;  "
;{
;  /* If this is a store, force the value into a register.  */
;  if (! (reload_in_progress || reload_completed))
;  {
;    printf(\"boop\\n\");
;    if (MEM_P (operands[0]))
;    {
;      operands[1] = force_reg (HImode, operands[1]);
;      if (MEM_P (XEXP (operands[0], 0)))
;        operands[0] = gen_rtx_MEM (HImode, force_reg (HImode, XEXP (operands[0], 0)));
;    }
;    else 
;      if (MEM_P (operands[1])
;          && MEM_P (XEXP (operands[1], 0)))
;        operands[1] = gen_rtx_MEM (HImode, force_reg (HImode, XEXP (operands[1], 0)));
;  }
;}")
;
;(define_insn "addsi3"
;  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
;         (plus:SI
;          (match_operand:SI 1 "register_operand" "0,0,0")
;          (match_operand:SI 2 "z80_add_operand" "I,N,r")))]
(define_insn "addqi3"
  [(set (match_operand:QI 0 "register_operand" "=yA,yA")
        (plus:QI
          (match_operand:QI 1 "register_operand" "0,0")
          (match_operand:QI 2 "z80_add_operand" "r,i")))]
  ""
  "@
  add %0, %2 # QI
  add %0, %2 # QI"
  [(set_attr "length" "2")])
(define_insn "addhi3"
  [(set (match_operand:HI 0 "register_operand" "=yB")
        (plus:HI
          (match_operand:HI 1 "register_operand" "0")
          (match_operand:HI 2 "z80_add_operand" "yC")))]
  ""
  "@
  add %0, %2 # HI"
  [(set_attr "length" "2")])
;; (define_split
;;   [(set (mem:HI
;;     (plus:HI (match_operand:HI 0 "register_operand" "") (match_operand:QI 1 "const_int_operand" "")))
;;     (match_operand:HI 2 "register_operand" ""))]
;;   ""
;;   [(set (mem:QI (plus:HI (match_dup 0) (match_dup 1))) (match_dup 3))]
;; {
;; printf("split\n");
;;   operands[2] = adjust_address(operands[0], QImode, 0);
;;   operands[3] = gen_lowpart(QImode, operands[1]);
;;   operands[4] = adjust_address(operands[0], QImode, 1);
;;   operands[5] = gen_highpart(QImode, operands[1]);
;; })
;; (define_expand "movhi_push"
;;   [(set (mem:HI (pre_dec:HI (reg:HI 15))) ; SP
;;        (match_operand:HI 0 "memory_operand" ""))]
;;   "reload_completed"
;; {
;; printf("push\n");
;;   operands[0] = force_reg(HImode, operands[0]);
;; })
(define_expand "movhi_push"
  [(set (mem:HI (pre_dec:HI (reg:HI 15))) ; SP
       (match_operand:HI 0 "nonimmediate_operand" "r"))]
  "reload_completed"
{
printf("push expand\n");
  operands[0] = force_reg(HImode, operands[0]);
})
(define_insn "movhi_push_ex"
  [(set (mem:HI (pre_dec:HI (reg:HI 15))) ; SP
       (match_operand:HI 0 "nonimmediate_operand" "r,m"))]
  ""
  "@
  push   %0
  push.m %0")

; Pop a register from the stack
(define_insn "movhi_pop_ex"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,m")
       (mem:HI (pre_dec:HI (reg:HI 15))))] ; SP
  ""
  "@
  pop    %0
  pop.m %0")
(define_insn "movhi_push_pop"
  [(set (match_operand:HI 0 "register_operand" "=r")
        (match_operand:HI 1 "register_operand" "r"))]
  ""
  "push %0; pop %1")
;; (define_insn "test1"
;;   [(set (mem:HI (pre_dec:HI (reg:HI 15)))
;;         (mem:HI (plus:HI (reg:HI 8)
;;                 (match_operand:HI 0 "const_int_operand" ""))))]
;;   ""
;;   "DERP")
;; (define_insn "test2"
;;   [(set (mem:HI (plus:HI (reg:HI 8)
;;                 (match_operand:HI 0 "const_int_operand" "")))
;;         (mem:HI (pre_dec:HI (reg:HI 15))))]
;;   ""
;;   "DERP")
;; (define_split
;;   [(set (match_operand:HI 0 "nonimmediate_operand")
;;         (match_operand:HI 1 "general_operand"))]
;;   ""
;;   [(set (subreg:QI (match_dup 0) 0) 
;;         (subreg:QI (match_dup 1) 0))
;;    (set (subreg:QI (match_dup 0) 1) 
;;         (subreg:QI (match_dup 1) 1))]
;;   "")
(define_insn "movhi3"
  [(set (match_operand:HI 0 "register_operand" "=yC")
        (match_operand:HI 1 "immediate_operand" "i"))]
  ""
  "ld.w %0, %1")
(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand" "")
	(match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
  /* If this is a store, force the value into a register.  */
  printf(\"movhi\\n\");
  if (MEM_P(operands[0]) && REG_P(operands[1])) {
      printf(\"move:hi m, r\\n\");
      emit_move_insn(adjust_address(operands[0], QImode, 0), gen_lowpart(QImode, operands[1]));
      emit_move_insn(adjust_address(operands[0], QImode, 1), gen_highpart(QImode, operands[1]));
      DONE;
    } else if (MEM_P(operands[1]) && REG_P(operands[0])) {
      printf(\"move:hi r, m\\n\");
      emit_move_insn(gen_lowpart(QImode, operands[0]), adjust_address(operands[1], QImode, 0));
      emit_move_insn(gen_highpart(QImode, operands[0]), adjust_address(operands[1], QImode, 1));
      DONE;
    } else if (MEM_P(operands[0]) && CONST_INT_P(operands[1])) {
      printf(\"move:hi m, i\\n\");
      emit_move_insn(adjust_address(operands[0], QImode, 0), gen_lowpart(QImode, operands[1]));
      emit_move_insn(adjust_address(operands[0], QImode, 1), gen_lowpart(QImode, GEN_INT(INTVAL(operands[1]) >> 8)));
      DONE;
     /*} else if (REG_P(operands[0]) && CONST_INT_P(operands[1])) {
       printf(\"move:hi r, i\\n\");
       emit_move_insn(gen_lowpart(QImode, operands[0]), gen_lowpart(QImode, operands[1]));
       emit_move_insn(gen_highpart(QImode, operands[0]), gen_lowpart(QImode, GEN_INT(INTVAL(operands[1]) >> 8)));
       DONE;*/
    } else if (REG_P(operands[0]) && REG_P(operands[1])) {
      printf(\"move:hi r, r\\n\");
      if(REGNO_PTR_FRAME_P(REGNO(operands[0])))
        printf(\"operands[0] is frame pointer\\n\");
      if(REGNO_PTR_FRAME_P(REGNO(operands[1])))
        printf(\"operands[1] is frame pointer\\n\");
      //emit_insn(gen_movhi_push(force_not_mem(operands[1])));
      //emit_insn(gen_movhi_pop_ex(force_not_mem(operands[0])));
      //emit_move_insn(gen_lowpart(QImode, operands[0]), gen_lowpart(QImode, operands[1]));
      //emit_move_insn(gen_highpart(QImode, operands[0]), gen_highpart(QImode, operands[1]));
      emit_insn(gen_movqi(simplify_gen_subreg(QImode, operands[0], HImode, 0), simplify_gen_subreg(QImode, operands[1], HImode, 0)));
      emit_insn(gen_movqi(simplify_gen_subreg(QImode, operands[0], HImode, 1), simplify_gen_subreg(QImode, operands[1], HImode, 1)));
      DONE;
    } else if (MEM_P(operands[0]) && MEM_P(operands[1])) {
      operands[1] = force_reg(HImode, operands[1]);
    }
//   if (MEM_P (operands[0]))
//     operands[1] = force_reg (HImode, operands[1]);
}")
(define_expand "movhi2"
  [(set (match_operand:HI 0 "memory_operand" "")
        (match_operand:HI 1 "memory_operand" ""))]
  ""
  "
{
  /* If this is a store, force the value into a register.  */
  printf(\"movhi2\\n\");
  
      operands[1] = force_reg(HImode, operands[1]);
}")
;; (define_insn "movhi_ix"
;;   [(set (match_operand:HI 0 "memory_operand" "") (match_operand:HI 1 "register_operand" ""))]
;;   ""
;;   {
;;     if (MEM_P(operands[0]) && REG_P(operands[1])) {
;;       printf(\"move:hi m, r\\n\");
;;       emit_move_insn(adjust_address(operands[0], QImode, 0), gen_lowpart(QImode, operands[1]));
;;     } else if (MEM_P(operands[1]) && REG_P(operands[0])) {
;;       printf(\"move:hi r, m\\n\");
;;     }
;;   })
;; (define_insn "movhi_ix2"
;;   [(set (match_operand:HI 0 "register_operand" "") (match_operand:HI 1 "memory_operand" ""))]
;;   ""
;;   {
;;     
;;   })
;; (define_insn "*movhi"
;;   [(set (match_operand:HI 0 "register_operand" "+r,r")
;;         (match_operand:HI 1 "general_operand" "I16,V"))]
;;   ""
;;   "@
;;   ld %0, %1
;;   ld %0, %1"
;;   [(set_attr "length"   "2,2")])
(define_insn "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "+r,r,m,r")
        (match_operand:QI 1 "general_operand" "I08,r,r,m"))]
  ""
  "@
  ld %0, #%1
  ld %0, %1
  ld (%0), %1
  ld %0, (%1)")
;(define_insn "store_by_ix"
;  [(set (match_operand:QI 0 "nonimmediate_operand" "
;(define_insn "*movsi"
;  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,W,A,r,r,B,r")
;	(match_operand:SI 1 "z80_general_movsrc_operand" "O,r,i,r,r,W,A,r,B"))]
;  "register_operand (operands[0], SImode)
;   || register_operand (operands[1], SImode)"
;  "@
;   xor    %0, %0
;   mov    %0, %1
;   ldi.l  %0, %1
;   st.l   %0, %1
;   sta.l  %0, %1
;   ld.l   %0, %1
;   lda.l  %0, %1
;   sto.l  %0, %1
;   ldo.l  %0, %1"
;  [(set_attr "length"	"2,2,6,2,6,2,6,6,6")])
;
;(define_insn_and_split "zero_extendqisi2"
;  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
;	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "0,W,A,B")))]
;  ""
;  "@
;   ;
;   ld.b   %0, %1
;   lda.b  %0, %1
;   ldo.b  %0, %1"
;  "reload_completed"
;  [(set (match_dup 2) (match_dup 1))
;   (set (match_dup 0) (zero_extend:SI (match_dup 2)))]
;{
;  operands[2] = gen_lowpart (QImode, operands[0]);
;}
;  [(set_attr "length" "0,2,6,6")])
;
;(define_insn_and_split "zero_extendhisi2"
;  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
;	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "0,W,A,B")))]
;  ""
;  "@
;   ;
;   ld.s   %0, %1
;   lda.s  %0, %1
;   ldo.s  %0, %1"
;  "reload_completed"
;  [(set (match_dup 2) (match_dup 1))
;   (set (match_dup 0) (zero_extend:SI (match_dup 2)))]
;{
;  operands[2] = gen_lowpart (HImode, operands[0]);
;}
;  [(set_attr "length" "0,2,6,6")])
;
;(define_insn "extendqisi2"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r")))]
;  ""
;  "@
;   sex.b  %0, %1"
;  [(set_attr "length" "2")])
;
;(define_insn "extendhisi2"
;  [(set (match_operand:SI 0 "register_operand" "=r")
;	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r")))]
;  ""
;  "@
;   sex.s  %0, %1"
;  [(set_attr "length" "2")])
;
;(define_expand "movqi"
;  [(set (match_operand:QI 0 "general_operand" "")
;	(match_operand:QI 1 "general_operand" ""))]
;  ""
;  "
;{
;  /* If this is a store, force the value into a register.  */
;  if (MEM_P (operands[0]))
;    operands[1] = force_reg (QImode, operands[1]);
;}")
;
;(define_insn "*movqi"
;  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,r,W,A,r,r,B,r")
;	(match_operand:QI 1 "z80_general_movsrc_operand" "O,r,i,r,r,W,A,r,B"))]
;  "register_operand (operands[0], QImode)
;   || register_operand (operands[1], QImode)"
;  "@
;   xor    %0, %0
;   mov    %0, %1
;   ldi.b  %0, %1
;   st.b   %0, %1
;   sta.b  %0, %1
;   ld.b   %0, %1
;   lda.b  %0, %1
;   sto.b  %0, %1
;   ldo.b  %0, %1"
;  [(set_attr "length"	"2,2,6,2,6,2,6,6,6")])
;
;(define_expand "movhi"
;  [(set (match_operand:HI 0 "general_operand" "")
;	(match_operand:HI 1 "general_operand" ""))]
;  ""
;  "
;{
;  /* If this is a store, force the value into a register.  */
;  if (MEM_P (operands[0]))
;    operands[1] = force_reg (HImode, operands[1]);
;}")
;
;(define_insn "*movhi"
;  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,W,A,r,r,B,r")
;	(match_operand:HI 1 "z80_general_movsrc_operand" "O,r,i,r,r,W,A,r,B"))]
;  "(register_operand (operands[0], HImode)
;    || register_operand (operands[1], HImode))"
;  "@
;   xor    %0, %0
;   mov    %0, %1
;   ldi.s  %0, %1
;   st.s   %0, %1
;   sta.s  %0, %1
;   ld.s   %0, %1
;   lda.s  %0, %1
;   sto.s  %0, %1
;   ldo.s  %0, %1"
;  [(set_attr "length"	"2,2,6,2,6,2,6,6,6")])
;
;; -------------------------------------------------------------------------
;; Compare instructions
;; -------------------------------------------------------------------------
;
;(define_constants
;  [(CC_REG 11)])
;
;(define_expand "cbranchsi4"
;  [(set (reg:CC CC_REG)
;        (compare:CC
;         (match_operand:SI 1 "general_operand" "")
;         (match_operand:SI 2 "general_operand" "")))
;   (set (pc)
;        (if_then_else (match_operator 0 "comparison_operator"
;                       [(reg:CC CC_REG) (const_int 0)])
;                      (label_ref (match_operand 3 "" ""))
;                      (pc)))]
;  ""
;  "
;  /* Force the compare operands into registers.  */
;  if (GET_CODE (operands[1]) != REG)
;	operands[1] = force_reg (SImode, operands[1]);
;  if (GET_CODE (operands[2]) != REG)
;	operands[2] = force_reg (SImode, operands[2]);
;  ")
;
;(define_insn "*cmpsi"
;  [(set (reg:CC CC_REG)
;	(compare
;	 (match_operand:SI 0 "register_operand" "r")
;	 (match_operand:SI 1 "register_operand"	"r")))]
;  ""
;  "cmp    %0, %1")
;
;
;; -------------------------------------------------------------------------
;; Branch instructions
;; -------------------------------------------------------------------------
;
;(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
;(define_code_attr CC [(ne "ne") (eq "eq") (lt "lt") (ltu "ltu") 
;		      (gt "gt") (gtu "gtu") (ge "ge") (le "le") 
;		      (geu "geu") (leu "leu") ])
;(define_code_attr rCC [(ne "eq") (eq "ne") (lt "ge") (ltu "geu") 
;		       (gt "le") (gtu "leu") (ge "lt") (le "gt") 
;		       (geu "ltu") (leu "gtu") ])
;
;(define_insn "*b<cond:code>"
;  [(set (pc)
;	(if_then_else (cond (reg:CC CC_REG)
;			    (const_int 0))
;		      (label_ref (match_operand 0 "" ""))
;		      (pc)))]
;  ""
;{
;  if (get_attr_length (insn) == 2)
;    return "b<CC>   %l0";
;  else
;    return "b<rCC>   .+6\n\tjmpa   %l0";
;}
;  [(set (attr "length")
;        (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 1022))
;                      (const_int 2) (const_int 8)))])
;
;; -------------------------------------------------------------------------
;; Call and Jump instructions
;; -------------------------------------------------------------------------
;
(define_expand "call"
  [(call (match_operand:HI 0 "memory_operand" "")
		(match_operand 1 "general_operand" ""))]
  ""
{
  gcc_assert (MEM_P (operands[0]));
})

(define_insn "call_ex"
  [(call (mem:HI (match_operand:HI 0 "memory_operand" "i"))
	 (match_operand 1 "" ""))]
  ""
  "call %0"
 [(set_attr "length"	"6")])

(define_expand "call_value"
  [(set (match_operand 0 "" "")
        (call:HI (match_operand 1 "address_operand")
                 (match_operand 2 "immediate_operand")))]
  ""
  ""
)

(define_insn "call_value_internal"
  [(set (match_operand:HI               0 "" "")
        (call (mem:QI (match_operand:HI 1 "address_operand" "i"))
              (match_operand 2 "immediate_operand" "i")))]
  ""
  "call %1"
)
;
;(define_insn "*call_value_indirect"
;  [(set (match_operand 0 "register_operand" "=r")
;	(call (mem:QI (match_operand:SI
;		       1 "register_operand" "r"))
;	      (match_operand 2 "" "")))]
;  ""
;  "jsr    %1")
;
(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "nonimmediate_operand" "r"))]
  ""
  "jp    (%0)")
;
; TODO: Add in distance checking for jp/jr
(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jp   %l0"
  [(set_attr "length"  "3")])
;
;
;; -------------------------------------------------------------------------
;; Prologue & Epilogue
;; -------------------------------------------------------------------------
;
(define_expand "prologue"
  [(clobber (const_int 0))]
  ""
  "
;{
;  z80_expand_prologue ();
;  DONE;
;}
")

(define_expand "epilogue"
  [(return)]
  ""
  "
;{
;  z80_expand_epilogue ();
;  DONE;
;}
")
;
(define_insn "returner"
  [(return)]
  "reload_completed"
  "ret")
;